<!DOCTYPE html>
<html lang="en">

<head>
    <title>2D Puzzle</title>
</head>


<body>
    <canvas id="myCanvas" width="1200" height="900"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // create new scene 
        var scene = new THREE.Scene();

        // set up the camera 
        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 5000);
        camera.position.x = 600;
        camera.position.y = 275;
        camera.position.z = 4000;
        camera.lookAt(new THREE.Vector3(600, 275, 0));
        scene.add(camera);

        // create renderer 
        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        // set the background color of the canvas
        renderer.setClearColor(0xecf987);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Creates a Triangle
        function Triangle(v1, v1Col, v2, v2Col, v3, v3Col) {
            this.vertices = [...v1, ...v2, ...v3, ...v1, ...v3, ...v2];

            this.colors = [...v1Col, ...v2Col, ...v3Col, ...v1Col, ...v3Col, ...v2Col];

            this.geometry = new THREE.BufferGeometry();
            this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.colors), 3));
            var material = new THREE.MeshBasicMaterial({ vertexColors: true });
            this.mesh = new THREE.Mesh(this.geometry, material);
            scene.add(this.mesh);

        }

        var listener = new THREE.AudioListener();
        camera.add(listener);


        // Creates a Puzzle Piece
        function puzzlePiece(v1, v2, v3, og, col) {
            this.vertices = [...v1, ...v2, ...v3];
            this.color = col;

            // use bufferGeometry to pass in the vertices and colors and create the triangles
            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            var material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, material);
            scene.add(this.mesh);

            // Bouding box of the piece
            this.boundingBox = new THREE.Box3();
            this.boundingBox.setFromObject(this.mesh);

            // Vertex that will act as the origin of the puzzle piece (bottom must vertex)
            this.origin = [this.boundingBox.min.x, this.boundingBox.min.y, this.boundingBox.min.z];

            // Width and height of the piece
            this.width = this.boundingBox.max.x - this.boundingBox.min.x;
            this.height = this.boundingBox.max.y - this.boundingBox.min.y;

            // Funtion to move puzzle piece
            this.move = function (newVertex) {
                // Moves it along the X axis
                this.mesh.translateX(newVertex[0] - this.origin[0]);

                // Moves it along the Y axis
                this.mesh.translateY(newVertex[1] - this.origin[1]);

                // Updates the origin vertex
                this.origin = newVertex;

                // Updates bounding box
                this.boundingBox.setFromObject(this.mesh);
            }

            // Adds puzzle piece into arra of objects that can be moved
            moveableObjects.push(this.mesh);
        }

        // Creates a Puzzle Board
        function puzzleBoard(v1, col, cellWidth, cellHeight, horizontalCells, verticalCells) {
            // Width of the Puzzle Board
            this.width = (cellWidth * horizontalCells) + (cellWidth * (horizontalCells * .15));

            // Height of the Puzzle Board
            this.height = (cellHeight * verticalCells) + (cellHeight * (verticalCells * .15));

            this.vertices = [
                ...v1, v1[0] + this.width, v1[1], v1[2], v1[0] + this.width, v1[1] + this.height, v1[2], // Bottom right triangle
                ...v1, v1[0] + this.width, v1[1] + this.height, v1[2], v1[0], v1[1] + this.height, v1[2] // Top left triangle
            ];
            this.color = col;

            // Amount of cells horizontally
            this.horCells = horizontalCells;

            // Amount of cells vertically
            this.verCells = verticalCells;

            // Width of the cells
            this.horGap = cellWidth + (cellWidth * .1);

            // Height of the cells
            this.verGap = cellHeight + (cellHeight * .1);

            // Array of anchor points in the cells
            this.points = [];

            // Array to check if anchor point has been occupied
            this.occupied = [];

            // Vertex to act as the template for the ancher points
            this.template = [v1[0] + (this.horGap * .1), v1[1] + (this.verGap * .1)];
            // Loop will iterate vertically (act as the Y)
            for (var y = 0; y < this.verCells; y++) {

                // Loop will iterate horizonatlly (act as the X)
                for (var x = 0; x < this.horCells; x++) {

                    // Adds an anchor point and adds false
                    this.points.push([this.template[0] + (x * this.horGap), this.template[1] + (y * this.verGap), 0])
                    this.occupied.push(false);
                }
            }

            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            var material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, material);
            scene.add(this.mesh);
        }

        // Moves the puzzle pieces from where they're created to the puzzle board
        function relocate(pieces, board) {

            // Index to randomly select a point
            var current = Math.floor(Math.random() * 100) % board.points.length;
            for (var i = 0; i < pieces.length; i++) {
                // If the current points is occupied get a new index
                while (board.occupied[current]) {
                    current = Math.floor(Math.random() * (board.points.length - 1));
                }

                // Moves the piece and sets point to occupied
                pieces[i].move(board.points[current]);
                board.occupied[current] = true;

            }

        }

        // Array of moveable objects (mesh)
        var moveableObjects = [];

        { // var puzzlePieces
            var puzzlePieces = [
                new puzzlePiece([-117.5, -235, 0], [117.5, -235, 0], [117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([-117.5, -235, 0], [117.5, 235, 0], [-117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([117.5, -235, 0], [235, -117.5, 0], [117.5, -117.5, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([117.5, -117.5, 0], [235, -117.5, 0], [235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([117.5, -117.5, 0], [235, 117.5, 0], [117.5, 117.5, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([117.5, 117.5, 0], [235, 117.5, 0], [117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([-235, 117.5, 0], [-117.5, 117.5, 0], [-117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([-235, -117.5, 0], [-117.5, -117.5, 0], [-235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([-117.5, -117.5, 0], [-117.5, 117.5, 0], [-235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
                new puzzlePiece([-117.5, -235, 0], [-117.5, -117.5, 0], [-235, -117.5, 0], [1, 0, 0], [1, 1, 1])
            ];
        }

        // Max width and height of all the piecex
        var maxWidth = 0;
        var maxHeight = 0;

        // Getting the values for the max width and height
        for (var i = 0; i < puzzlePieces.length; i++) {
            if (puzzlePieces[i].width > maxWidth) {
                maxWidth = puzzlePieces[i].width;
            }

            if (puzzlePieces[i].height > maxHeight) {
                maxHeight = puzzlePieces[i].height;
            }
        }

        { // var piecesBoard
            var piecesBoard = new puzzleBoard(
                [650, -675, -10], 0x99ffff, maxWidth, maxHeight,
                3, 4
            );
        }

        relocate(puzzlePieces, piecesBoard);

        // Function to create a square
        function Square(v1, v1Col, v2, v2Col, v3, v3Col, v4, v4Col) {
            this.tri1 = new Triangle(v1, v1Col, v2, v2Col, v3, v3Col);
            this.tri2 = new Triangle(v1, v1Col, v3, v3Col, v4, v4Col);
        }


        // create an octagon object which passes in 9 vertices and 9 colors for each vertex
        function Octagon(vertices, colors) {

            this.vertices = vertices;
            this.colors = colors;

            // create a group object to enable moving all of the triangles within the octagon
            this.group = new THREE.Group();

            console.log(this.vertices[0]);

            // create 8 triangles to form an octagon
            this.triangles = [
                new Triangle(this.vertices[0], this.colors, this.vertices[1], this.colors, this.vertices[2], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[2], this.colors, this.vertices[3], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[3], this.colors, this.vertices[4], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[4], this.colors, this.vertices[5], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[5], this.colors, this.vertices[6], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[6], this.colors, this.vertices[7], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[7], this.colors, this.vertices[8], this.colors),
                new Triangle(this.vertices[0], this.colors, this.vertices[8], this.colors, this.vertices[1], this.colors)
            ];
            // for each loop to add all meshes to the group and display bounding boxes for them
            this.triangles.forEach(tri => {
                this.group.add(tri.mesh);
            });
            // add the group of triangles to the scene
            scene.add(this.group);
        }

        // function to handle snapping  
        function snapTo(triangles, targetVector, threshold) {
            // for every triangle in the array of triangles 
            for (var i = 0; i < triangles.length; i++) {
                // if the position of the current triangle's distance is less than or equal to the threshold
                if (triangles[i].mesh.position.distanceTo(targetVector) <= threshold) {
                    triangles[i].mesh.position.copy(targetVector)
                }
            }
        }

        function watermelonSeeds(triangles) {
            // use the vertices of the triangle + scalar create fractal like pattern
            var points = [];
            points.push(-450, 435, 5);
            points.push(-350, 435, 5);
            points.push(-400, 375, 5);
            points.push(-400, 500, 5);
            points.push(-400, 430, 5);
            points.push(-475, 500, 5);
            points.push(-325, 500, 5);
            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            var material = new THREE.PointsMaterial({ size: 5, sizeAttenuation: false, color: 0x000000 }); // Red color for now
            var point = new THREE.Points(geometry, material);
            scene.add(point);
        }

        // List of vertices to be defined for the main octagon board
        const mainBoardVertices = [
            [0 - 400, 130 + 200, 0],    // v1, origin vertex
            [100 - 400, 380 + 200, 0],  // v2
            [250 - 400, 230 + 200, 0],  // v3
            [250 - 400, 30 + 200, 0],   // v4
            [100 - 400, -120 + 200, 0], // v5
            [-100 - 400, -120 + 200, 0],// v6
            [-250 - 400, 30 + 200, 0],  // v7
            [-250 - 400, 230 + 200, 0], // v8
            [-100 - 400, 380 + 200, 0], // v9
        ];
        const mainBoardColors = [0.2, 0.3, 0.1];

        console.log("mainboard")

        const octagon2 = new Octagon(mainBoardVertices, mainBoardColors);


        // List of vertices for the pieces
        var pieceVertices = [
            [0 - 400, 325, 0], // origin vertex, v1
            [224.51 - 400, 418.99 + 5, 0],  //v2
            [93.0 - 400, 549.51 + 5, 0],    //v3
            [-93.0 - 400, 549.51 + 5, 0],   //v4
            [-224.51 - 400, 418.99 + 5, 0], //v5
            [-224.51 - 400, 231.01 + 5, 0], //v6
            [-93 - 400, 100.49 + 5, 0],     //v7
            [93 - 400, 100.49 + 5, 0],      //v8
            [224.51 - 400, 231.01 + 5, 0],  //v9

            [125, 515, 0], //v6out
            [125, 515, 0], //v6in
            [-125, 515, 0], //v7out
            [-125, 515, 0] //v7in
        ];

        // All of the pieces will be the same color
        const pieceColors = [0.9, 0.2, 0.2];

        console.log("pieeces")

        var octagon = new Octagon(pieceVertices, pieceColors);

        var seeds = new watermelonSeeds(octagon.triangles);



        // { // var octagon
        //     var octagon = new Octagon(
        // 
        //         // origin vertex
        //         [0 - 400, 325, 0], [0.9, 0.1, 0.1],
        //         [224.51 - 400, 418.99 + 5, 0], [0.9, 0.2, 0.2],
        //         [93.0 - 400, 549.51 + 5, 0], [0.9, 0.2, 0.2],
        //         [-93.0 - 400, 549.51 + 5, 0], [0.9, 0.2, 0.2],
        //         [-224.51 - 400, 418.99 + 5, 0], [0.9, 0.2, 0.2],
        //         [-224.51 - 400, 231.01 + 5, 0], [0.9, 0.2, 0.2],
        //         [-93 - 400, 100.49 + 5, 0], [0.9, 0.2, 0.2],
        //         [93 - 400, 100.49 + 5, 0], [0.9, 0.2, 0.2],
        //         [224.51 - 400, 231.01 + 5, 0], [0.9, 0.2, 0.2],
        //     );
        // }

        var seeds = new watermelonSeeds(octagon.triangles);

        // Helper function for the above.
        /** Generate a random integer number between min and max. */
        function getRandomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /** Create points within the octagon's range. Used to help plot the vertices of the puzzle pieces. */
        function VertexPoint() {
            var points = [];

            points.push(0 - 400, 325, 0); //v1
            points.push(224.51 - 400, 418.99 + 5, 0); //v2
            points.push(93.0 - 400, 549.51 + 5, 0); //v3
            points.push(-93.0 - 400, 549.51 + 5, 0); //v4
            points.push(-224.51 - 400, 418.99 + 5, 0); //v5
            points.push(-224.51 - 400, 231.01 + 5, 0); //v6

            points.push(60 - 400, 515 + 5, 0); //v6Out
            points.push(60 - 400, 387 + 5, 0); //v6In
            points.push(-60 - 400, 515 + 5, 0); //v7Out
            points.push(-60 - 400, 387 + 5, 0); //v7In


            points.push(-93 - 400, 100.49 + 5, 0); //v7
            points.push(93 - 400, 100.49 + 5, 0); //v8
            points.push(224.51 - 400, 231.01 + 5, 0); //v9

            // Render the points
            this.render = function () {
                var geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                // Make the points invisible after ensuring the snap function works
                var material = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false, color: 0xab2323 }); // Red color for now
                var point = new THREE.Points(geometry, material);
                scene.add(point);
            }
        }

        // Display the points
        // var pt = new VertexPoint();
        // pt.render();

        // create an array of objects
        var objects = [octagon.group];

        // pass in the array to the dragControls object
        var dControls = new DragControls(objects, camera, renderer.domElement);

        // eventListener which detects when an object has been 'clicked' and is being 'dragged'
        dControls.addEventListener('dragstart', function (event) {
            var sound = new THREE.Audio(listener);
            var audioLoader = new THREE.AudioLoader();
            audioLoader.load('http://localhost:5173/assets/sounds/mouse click final.mp3', function (buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(false);
                sound.setVolume(0.5);
                sound.play();
            })

        })

        // eventListener which detects when an object is no longer being dragged
        dControls.addEventListener('dragend', function (event) {
            // snapTo function which occurs when an object is let go of in the range of intersection
            var targetVector = new THREE.Vector3(0, 0, 0);
            snapTo(octagon.triangles, targetVector, 40)
        })

        // Adjusting camera aspect to account for window rezise
        window.addEventListener('resize', function (event) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // function to allow the scene to continuously update 
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

    </script>

</body>

</html>