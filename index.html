<!DOCTYPE html>
<html lang="en">


<head>
    <title>2D Puzzle</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <canvas id="myCanvas" width="1200" height="900"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // create new scene 
        var scene = new THREE.Scene();

        // set up the camera 
        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 5000);
        camera.position.x = 600;
        camera.position.y = 275;
        camera.position.z = 4000;
        camera.lookAt(new THREE.Vector3(600, 275, 0));
        scene.add(camera);

        // create renderer 
        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });

        // set the background color of the canvas
        renderer.setClearColor(0xecf987);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var listener = new THREE.AudioListener();
        camera.add(listener);

        // Creates a Triangle
        function Triangle(v1, v2, v3, col) {
            this.vertices = [];
            addVector(this.vertices, v1);
            addVector(this.vertices, v2);
            addVector(this.vertices, v3);

            this.color = col;

            this.geometry = new THREE.BufferGeometry();
            this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            var material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(this.geometry, material);
            scene.add(this.mesh);

            // Add vector to array
            function addVector(arr, vector) {
                arr.push(vector.x);
                arr.push(vector.y);
                arr.push(vector.z);
            }

        }

        // create an octagon object which passes in 9 vertices and 9 colors for each vertex
        function Octagon(vertices, color) {

            this.vertices = vertices;

            this.color = color;


            // create 8 triangles to form an octagon
            this.triangles = [
                new Triangle(this.vertices[0], this.vertices[1], this.vertices[2], this.color),
                new Triangle(this.vertices[0], this.vertices[2], this.vertices[3], this.color),
                new Triangle(this.vertices[0], this.vertices[3], this.vertices[4], this.color),
                new Triangle(this.vertices[0], this.vertices[4], this.vertices[5], this.color),
                new Triangle(this.vertices[0], this.vertices[5], this.vertices[6], this.color),
                new Triangle(this.vertices[0], this.vertices[6], this.vertices[7], this.color),
                new Triangle(this.vertices[0], this.vertices[7], this.vertices[8], this.color),
                new Triangle(this.vertices[0], this.vertices[8], this.vertices[1], this.color)
            ];

        }

        // Creates a Puzzle Piece
        function puzzlePiece(geometry, material) {
            this.mesh = new THREE.Mesh(geometry, material);
            scene.add(this.mesh);

            // Bounding box of the piece
            this.boundingBox = new THREE.Box3();
            this.boundingBox.setFromObject(this.mesh);

            var helper = new THREE.Box3Helper(this.boundingBox, 0x000000);
            scene.add(helper);


            // Vertex that will act as the origin of the puzzle piece (bottom must vertex)
            this.origin = new THREE.Vector3(this.boundingBox.min.x, this.boundingBox.min.y, this.boundingBox.min.z)

            // Width and height of the piece
            this.width = this.boundingBox.max.x - this.boundingBox.min.x;
            this.height = this.boundingBox.max.y - this.boundingBox.min.y;

            // Function to move puzzle piece
            this.move = function (newVertex) {
                // Moves it along the X axis
                this.mesh.translateX(newVertex.x - this.origin.x);

                // Moves it along the Y axis
                this.mesh.translateY(newVertex.y - this.origin.y);

                // Updates the origin vertex
                this.origin = newVertex;

                // Updates bounding box
                this.boundingBox.setFromObject(this.mesh);
            }

            // Adds puzzle piece into array of objects that can be moved
            moveableObjects.push(this.mesh);
        }

        // Creates a Puzzle Board
        function puzzleBoard(v1, col, cellWidth, cellHeight, pieceNum) {
            this.ver = 6;
            this.hor = Math.ceil(pieceNum / 4);

            // Width of the Puzzle Board
            this.width = (cellWidth * this.hor) + (cellWidth * (this.hor * .15));

            // Height of the Puzzle Board
            this.height = (cellHeight * this.ver) + (cellHeight * (this.ver * .15));

            // Adding the vectors to the array
            this.vertices = [];
            addVector(this.vertices, v1);
            this.vertices.push(
                v1.x + this.width, v1.y, v1.z, v1.x + this.width, v1.y + this.height, v1.z // Bottom right triangle
            );
            addVector(this.vertices, v1);
            this.vertices.push(
                v1.x + this.width, v1.y + this.height, v1.z, v1.x, v1.y + this.height, v1.z // Top left triangle
            );

            this.color = col;

            // Width of the cells
            this.horGap = cellWidth + (cellWidth * .1);

            // Height of the cells
            this.verGap = cellHeight + (cellHeight * .1);

            // Array of anchor points in the cells
            this.points = [];

            // Array to check if anchor point has been occupied
            this.occupied = [];


            // Vertex to act as the template for the ancher points
            this.template = new THREE.Vector2(v1.x + (this.horGap * .1), v1.y + (this.verGap * .1));

            // Loop will iterate vertically (act as the Y)
            for (var y = 0; y < this.ver; y++) {

                // Loop will iterate horizontally (act as the X)
                for (var x = 0; x < this.hor; x++) {

                    // Adds an anchor point and adds false
                    this.points.push(new THREE.Vector3(this.template.x + (x * this.horGap), this.template.y + (y * this.verGap), 0));
                    this.occupied.push(false);
                }
            }

            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            var material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, material);
            //scene.add(this.mesh);


            // Add vector to array
            function addVector(arr, vector) {
                arr.push(vector.x);
                arr.push(vector.y);
                arr.push(vector.z);
            }
        }
        function Point(position) {
            this.position = [];
            addVector(position);

            this.Render = function () {
                var geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.position, 3));
                var material = new THREE.PointsMaterial({ 'color': 0x000000 });
                var points = new THREE.Points(geometry, material);
                scene.add(points);
            }
            this.Render();

            function addVector(arr, vector) {
                arr.push(vector.x);
                arr.push(vector.y);
                arr.push(vector.z);
            }
        }

        /** Creates the puzzle pieces. */
        function MakePuzzle(vertices, color) {
            this.v = vertices;
            this.color = color;
            this.triangles = [];
            this.used = [];
            this.pieces = [];


            for (var i = 1; i < 9; i++) {
                if (i === 8) {
                    this.v.push(new THREE.Vector3((this.v[0].x + this.v[i].x) / 2, (this.v[0].y + this.v[i].y) / 2, (this.v[0].z + this.v[i].z) / 2));
                    this.v.push(new THREE.Vector3((this.v[i].x + this.v[1].x) / 2, (this.v[i].y + this.v[1].y) / 2, (this.v[i].z + this.v[1].z) / 2));
                } else {
                    this.v.push(new THREE.Vector3((this.v[0].x + this.v[i].x) / 2, (this.v[0].y + this.v[i].y) / 2, (this.v[0].z + this.v[i].z) / 2));
                    this.v.push(new THREE.Vector3((this.v[i].x + this.v[i + 1].x) / 2, (this.v[i].y + this.v[i + 1].y) / 2, (this.v[i].z + this.v[i + 1].z) / 2));
                };
            };


            var k = 10;
            for (var i = 1; i < this.v.length - 1; i++) {
                if (i === 8) {
                    this.triangles.push(new Triangle(this.v[i], this.v[k], this.v[k - 1], this.color));
                    this.triangles.push(new Triangle(this.v[k], this.v[9], this.v[k - 1], this.color));
                    this.triangles.push(new Triangle(this.v[k], this.v[1], this.v[9], this.color));
                } else if (i === 23) {
                    this.triangles.push(new Triangle(this.v[i], this.v[9], this.v[0], this.color));
                } else if (i > 8) {
                    this.triangles.push(new Triangle(this.v[i], this.v[i + 2], this.v[0], this.color));
                    i++;
                } else {
                    this.triangles.push(new Triangle(this.v[i], this.v[k], this.v[k - 1], this.color));
                    this.triangles.push(new Triangle(this.v[k], this.v[k + 1], this.v[k - 1], this.color));
                    this.triangles.push(new Triangle(this.v[k], this.v[i + 1], this.v[k + 1], this.color));
                    k += 2;
                };
            };

            for (var i = 0; i < this.triangles.length; i++) {
                this.used.push(false);
            };

            shuffleArray(this.triangles)

            while (this.used.includes(false)) {
                var currT = Math.floor(Math.random() * 100) % this.triangles.length;
                var merge = [this.triangles[currT].geometry];
                var size = 1;
                var checked = 0;
                if (!this.used[currT]) { // If current triangle has not been used
                    this.used[currT] = true;
                    for (var i = 0; i < this.triangles.length; i++) {
                        if (size > 2) { // If they reached the maximun size then exit
                            break;
                        }

                        if (checkSide(this.triangles[currT], this.triangles[i])) { // Do they share a side
                            checked++;
                            if (!this.used[i]) { // If new tringle has not been used
                                var toBeOrNotToBe = Math.random() - .5;
                                if (toBeOrNotToBe >= -0.25) { // Wether to combine them or not
                                    this.used[i] = true;
                                    merge.push(this.triangles[i].geometry);
                                    currT = i;
                                    i = -1;
                                    checked = 1;
                                    size++;
                                }
                            }
                        }

                        if (checked === 3) { // If all 3 sides have been chaked then break
                            break;
                        }

                    }
                    var geometry = new BufferGeometryUtils.mergeGeometries(merge, false);
                    var material = new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()) });
                    this.pieces.push(new puzzlePiece(geometry, material));

                }



            }

        }

        // Moves the puzzle pieces from where they're created to the puzzle board
        function relocate(pieces, board) {

            // Index to randomly select a point
            var current = Math.floor(Math.random() * 100) % board.points.length;
            for (var i = 0; i < pieces.length; i++) {
                // If the current points is occupied get a new index
                while (board.occupied[current]) {
                    current = Math.floor(Math.random() * (board.points.length - 1));
                }

                // Moves the piece and sets point to occupied
                pieces[i].move(board.points[current]);
                board.occupied[current] = true;

            }

        }

        // Taken from GeeksForGeeks with minor changes
        function shuffleArray(arr) {
            var currIndex = arr.length - 1;

            // While there remain elements to shuffle...
            while (currIndex > -1) {
                // Pick a remaining element...
                let randIndex = Math.floor(Math.random() * currIndex);
                // And swap it with the current element.
                [arr[currIndex], arr[randIndex]] = [arr[randIndex], arr[currIndex]];

                currIndex--;
            };
        }

        function checkSide(t1, t2) {
            var v1 = t1.vertices;
            var v2 = t2.vertices;
            var share = 0;
            for (var i = 0; i < v1.length; i += 3) {
                if ((t1.vertices[i] == t2.vertices[0] && t1.vertices[i + 1] == t2.vertices[1]) ||
                    (t1.vertices[i] == t2.vertices[3] && t1.vertices[i + 1] == t2.vertices[4]) ||
                    (t1.vertices[i] == t2.vertices[6] && t1.vertices[i + 1] == t2.vertices[7])) {
                    share++
                }
            }
            return (share === 2) ? true : false;
        }

        /** A function to handle snapping a piece. */
        function snapTo(triangles, targetVector, threshold) {
            var snapCount = 0;
            var hasBeenSnapped = false;
            // for every triangle in the array of triangles 
            for (var i = 0; i < triangles.length; i++) {
                // if the position of the current triangle's distance is less than or equal to the threshold
                if (triangles[i].mesh.position.distanceTo(targetVector) <= threshold) {
                    // A piece has been placed around its correct location. Snap it into place.
                    triangles[i].mesh.position.copy(targetVector);
                    snapCount++;
                    hasBeenSnapped = true;

                    // Lock the piece in its correct spots into place / disable dragging by creating a new "fake" mesh 
                    moveableObjects[i] = new THREE.Mesh();

                }
                // Check if a new piece is actually in its correct location after the snapping function above
                if ((correctCount == (snapCount - 1)) && hasBeenSnapped) {
                    correctCount++;
                    if (correctCount == numOfPieces) {
                        // Play the "winning" sound
                        playSound('./assets/sounds/correct.mp3');
                        console.log("You Win");
                        break;
                    } else {
                        // Play the "correct" sound effect
                        playSound('./assets/sounds/correct.mp3');
                        break;
                    }
                }

            }
        }

        // var geometryUtils = new THREE.BufferGeometryUtils().mergeGeometries();

        var correctCount = 0;

        var numOfPieces;

        // Array of moveable objects (mesh)
        var moveableObjects = [];

        // List of vertices to be defined for the main octagon board
        const mainBoardVertices = [
            new THREE.Vector3(224.51, 224.51, 0), //v1
            new THREE.Vector3(124.51, -25.49, 0), // v2
            new THREE.Vector3(324.51, -25.49, 0), // v3
            new THREE.Vector3(474.51, 124.51, 0), // v4
            new THREE.Vector3(474.51, 324.51, 0), // v5
            new THREE.Vector3(324.51, 474.51, 0), //v6
            new THREE.Vector3(124.51, 474.51, 0), // v7
            new THREE.Vector3(-25.49, 324.51, 0), // v8
            new THREE.Vector3(-25.49, 124.51, 0) // v9
        ];

        const mainBoardColors = new THREE.Color(0.2, 0.3, 0.1);

        const mainBoard = new Octagon(mainBoardVertices, mainBoardColors);

        // List of vertices for the pieces
        var pieceVertices = [
            new THREE.Vector3(224.51, 224.51, 0), //v0
            new THREE.Vector3(131.51, 0, 10), // v1
            new THREE.Vector3(317.5, 0, 10), // v2
            new THREE.Vector3(449.02, 130.52, 10), // v3
            new THREE.Vector3(449.02, 318.5, 10), // v4
            new THREE.Vector3(317.51, 449.02, 10), // v5
            new THREE.Vector3(131.51, 449.02, 10), // v6
            new THREE.Vector3(0, 318.5, 10), // v7
            new THREE.Vector3(0, 130.56, 10), // v8
        ];

        // All of the pieces will be the same color
        const pieceColor = new THREE.Color(0.9, 0.2, 0.2);

        var puzzle = new MakePuzzle(pieceVertices, pieceColor);
        numOfPieces = puzzle.pieces.length;

        // Max width and height of all the pieces
        var maxWidth = 0;
        var maxHeight = 0;

        // Getting the values for the max width and height
        for (var i = 0; i < puzzle.pieces.length; i++) {


            if (puzzle.pieces[i].width > maxWidth) {
                maxWidth = puzzle.pieces[i].width;
            }

            if (puzzle.pieces[i].height > maxHeight) {
                maxHeight = puzzle.pieces[i].height;

            }
        }

        { // var piecesBoard
            var piecesBoard = new puzzleBoard(
                new THREE.Vector3(650, -675, -10), new THREE.Color(0, 1, 1), maxWidth, maxHeight,
                numOfPieces
            );
        }

        relocate(puzzle.pieces, piecesBoard);

        // pass in the array of moveableObjects into the dragControls
        var dControls = new DragControls(moveableObjects, camera, renderer.domElement);

        // eventListener which detects when an object has been 'clicked' and is being 'dragged'
        dControls.addEventListener('dragstart', function (event) {

            playSound('./assets/sounds/mouse_click_final.mp3');
        });

        // eventListener which detects when an object is no longer being dragged
        dControls.addEventListener('dragend', function (event) {
            // snapTo function which occurs when an object is let go of in the range of intersection
            var targetVector = new THREE.Vector3(0, 0, 0);
            snapTo(puzzle.pieces, targetVector, 40);
        });

        // Adjusting camera aspect to account for window resize
        window.addEventListener('resize', function (event) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        /** A function to play a given sound. ("Above and Beyond") */
        function playSound(audioFile) {
            const sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(audioFile, function (buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(false);
                sound.setVolume(0.5);
                sound.play();
            });
        }
        // function to allow the scene to continuously update 
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

    </script>

</body>

</html>