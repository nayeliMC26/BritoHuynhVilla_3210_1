<!DOCTYPE html>
<html>
<head>
    <title>CSC3210 Puzzle Pandemonium</title>
</head>
<body>
    <canvas id="myCanvas" width="1200" height="900"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        var size = 500;
        var divisions = 500;
        var gridHelper = new THREE.GridHelper( size, divisions );

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.y = 250;
        camera.position.x = 0;
        camera.position.z = 1000;
        camera.lookAt(new THREE.Vector3(0.0, 250, 0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x242424);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0,250,0);
        controls.update();

        function animate(){
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene,camera);
}

        function Octagon(position, color){
            this.position = position;
            this.color = color;

            this.render = function(){
                var geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.position, 3));
                var material = new THREE.LineBasicMaterial({'color': this.color});
                var line = new THREE.Line(geometry, material);
                scene.add(line);
            }
        }
        var points = [];
        for(var i = 0; i < 8 ; i++){
                points.push(-125,0,0), //v2
                points.push(125,0,0),  //v3
                points.push(250,125,0),  //v4
                points.push(250,375,0),  //v5
                points.push(125,500,0), //v6
                points.push (-125,500,0),  //v7
                points.push(-250,375,0),  //v8
                points.push(-250,125,0) //v9
        }
        scene.add( gridHelper );

        var octagon = new Octagon(points, [1,0.5,0]);
        octagon.render();

        /** Create random points within the octagon's range. */
        function RandomPoint(numPoints, minX, maxX, minY, maxY, minZ, maxZ) {
            var randPoints = [];
            for (var i = 0; i < numPoints; i++) {
                let x = getRandomNumber(minX, maxX);
                let y = getRandomNumber(minY, maxY);
                let z = getRandomNumber(minY, maxZ);

                randPoints.push(x, y, z);
            }

            // Render the points
            this.render = function() {
                var geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(randPoints, 3));
                // The color for the points could be made black after we create the inner polygons.
                var material = new THREE.PointsMaterial({ size: 6, sizeAttenuation: false, color: 0xab2323 }); // Red color for now
                var point = new THREE.Points(geometry, material);
                scene.add(point);
            }
        }

        /** Generate a random integer number between min and max. */
        function getRandomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Create random points inside the octagon.
        var pt = new RandomPoint(10, -125, 125, 125, 375, 0, 0);
        pt.render();

        animate();
        renderer.render(scene, camera);
    </script>
</body>
</html>