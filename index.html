<!DOCTYPE html>
<html lang="en">


<head>
    <title>2D Puzzle</title>
</head>


<body>
    <canvas id="myCanvas" width="1200" height="900"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 10000);
        camera.position.x = 600;
        camera.position.y = 275;
        camera.position.z = 4000;
        camera.lookAt(new THREE.Vector3(600, 275, 0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x603e34);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Creates a Triangle
        function Triangle(v1, v1Col, v2, v2Col, v3, v3Col) {
            this.vertices = [...v1, ...v2, ...v3];

            this.colors = [...v1Col, ...v2Col, ...v3Col];

            this.geometry = new THREE.BufferGeometry();
            this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.colors), 3));
            var material = new THREE.MeshBasicMaterial({ vertexColors: true });
            this.mesh = new THREE.Mesh(this.geometry, material);
            scene.add(this.mesh);

        }

        // Creates an Octagon
        function Octagon(v1, v1Col, v2, v2Col, v3, v3Col, v4, v4Col, v5, v5Col, v6, v6Col, v7, v7Col, v8, v8Col, v9, v9Col) {
            this.triangles = [
                new Triangle(v1, v1Col, v2, v2Col, v3, v3Col),
                new Triangle(v1, v1Col, v3, v3Col, v4, v4Col),
                new Triangle(v1, v1Col, v4, v4Col, v5, v5Col),
                new Triangle(v1, v1Col, v5, v5Col, v6, v6Col),
                new Triangle(v1, v1Col, v6, v6Col, v7, v7Col),
                new Triangle(v1, v1Col, v7, v7Col, v8, v8Col),
                new Triangle(v1, v1Col, v8, v8Col, v9, v9Col),
                new Triangle(v1, v1Col, v9, v9Col, v2, v2Col)
            ];
        }

        // Creates a Puzzle Piece
        function puzzlePiece(v1, v2, v3, og, col) {
            this.vertices = [...v1, ...v2, ...v3];
            this.color = col;

            // Vertex that will act as the origin of the puzzle piece (bottom must vertex)
            this.origin = [v1[0], v1[1], v1[2]];

            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            var material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, material);
            scene.add(this.mesh);

            // Funtion to move puzzle piece
            this.move = function (newVertex) {
                // Moves it along the X axis
                this.mesh.translateX(newVertex[0] - this.origin[0]);

                // Moves it along the Y axis
                this.mesh.translateY(newVertex[1] - this.origin[1]);

                // Updates the origin vertex
                this.origin = newVertex;
            }

            // Adds puzzle piece into arra of objects that can be moved
            moveableObjects.push(this.mesh);
        }

        // Creates a Puzzle Board
        function puzzleBoard(v1, v1Col, v2, v2Col, v3, v3Col, v4, v4Col, horizontal, vertical) {
            this.vertices = [...v1, ...v2, ...v3, ...v1, ...v3, ...v4];
            this.colors = [...v1Col, ...v2Col, ...v3Col, ...v1Col, ...v3Col, ...v4Col];

            // Amount of cells horizontally
            this.horCells = horizontal;

            // Amount of cells vertically
            this.verCells = vertical;

            // Width of the Puzzle Board
            this.width = v3[0] - v1[0];

            // Height of the Puzzle Board
            this.height = v3[1] - v1[1];

            // Width of the cells
            this.horGap = Math.floor(Math.abs(this.width / this.horCells));

            // Height of the cells
            this.verGap = Math.floor(Math.abs(this.height / this.verCells));


            // Array of ancher points in the cells
            this.points = [];

            // Array to check if ancher point has been occupied
            this.occupied = [];

            // Vertex to act as the template for the ancher points
            this.template = [v1[0] + (this.horGap / 2), v1[1] + (this.horGap / 2)];

            // Loop will iterate vertically (act as the Y)
            for (var y = 0; y < this.verCells; y++) {

                // Loop will iterate horizonatlly (act as the X)
                for (var x = 0; x < this.horCells; x++) {

                    // Adds an ancher point and adds false
                    this.points.push([this.template[0] + (x * this.horGap), this.template[1] + (y * this.verGap), 0])
                    this.occupied.push(false);
                }
            }

            var geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.colors), 3));
            var material = new THREE.MeshBasicMaterial({ vertexColors: true });
            this.mesh = new THREE.Mesh(geometry, material);
            scene.add(this.mesh);

        }

        // Moves the puzzle pieces from where they're created to the puzzle board
        function relocate(pieces, board) {

            // Index to randomly select a point
            var current = Math.floor(Math.random() * (board.points.length - 1));
            for (var i = 0; i < pieces.length; i++) {
                // If the current points is occupied get a new index
                while (board.occupied[current]) {
                    current = Math.floor(Math.random() * (board.points.length - 1));
                }

                // Moves the piece and sets point to occupied
                pieces[i].move(board.points[current])
                board.occupied[current] = true;

            }

        }

        // Array of moveable objects (mesh)
        var moveableObjects = [];

        var backGroundOctagon = new Octagon(
            [275, 275, 0], [0.4, 0.1, .1], //v1
            [0, 275, 0], [0.4, 0.1, .1], //v2
            [80, 80, 0], [0.6, 0.1, .1], //v3
            [275, 0, 0], [0.4, 0.1, .1], //v4
            [469, 80, 0], [0.4, 0.1, .1], //v5
            [550, 275, 0], [0.4, 0.1, .1], //v6
            [469, 469, 0], [0.4, 0.1, .1], //v7
            [275, 550, 0], [0.4, 0.1, .1], //v8
            [80, 469, 0], [0.4, 0.1, .1] //v9
        );

        var primaryOctagon = new Octagon(
            [275, 275, 0], [0.9, 0.2, 0.2], //v1
            [27, 275, 0], [0.9, 0.4, 0.2], //v2
            [100, 100, 0], [0.9, 0.4, 0.2], //v3
            [275, 27, 0], [0.9, 0.4, 0.2], //v4
            [449, 100, 0], [0.9, 0.4, 0.2], //v5
            [522, 275, 0], [0.9, 0.4, 0.2], //v6
            [449, 449, 0], [0.9, 0.4, 0.2], //v7
            [275, 522, 0], [0.9, 0.4, 0.2], //v8
            [100, 449, 0], [0.9, 0.4, 0.2] //v9
        );

        var piecesBoard = new puzzleBoard(
            [650, -675, -1], [1, 1, 0],
            [1900, -675, -1], [1, 0, 1],
            [1900, 1325, -1], [0, 1, 1],
            [650, 1325, -1], [1, 1, 1],
            3, 4
        );

        var puzzlePieces = [
            new puzzlePiece([-117.5, -235, 0], [117.5, -235, 0], [117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([-117.5, -235, 0], [117.5, 235, 0], [-117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([117.5, -235, 0], [235, -117.5, 0], [117.5, -117.5, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([117.5, -117.5, 0], [235, -117.5, 0], [235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([117.5, -117.5, 0], [235, 117.5, 0], [117.5, 117.5, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([117.5, 117.5, 0], [235, 117.5, 0], [117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([-235, 117.5, 0], [-117.5, 117.5, 0], [-117.5, 235, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([-235, -117.5, 0], [-117.5, -117.5, 0], [-235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([-117.5, -117.5, 0], [-117.5, 117.5, 0], [-235, 117.5, 0], [1, 0, 0], [1, 1, 1]),
            new puzzlePiece([-117.5, -235, 0], [-117.5, -117.5, 0], [-235, -117.5, 0], [1, 0, 0], [1, 1, 1])
        ];


        relocate(puzzlePieces, piecesBoard);

        // Drag Controls
        var dControls = new DragControls(moveableObjects, camera, renderer.domElement);

        // Adjusting camera aspect to account for window rezise
        window.addEventListener('resize', function (event) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

    </script>

</body>


/html>